<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多人联机 Meme 贪吃蛇</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    
    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        memeYellow: '#FFE100',
                        memeBlue: '#0066FF',
                        memeRed: '#FF3333',
                        memeGreen: '#33CC33',
                        memePink: '#FF66CC',
                    },
                    fontFamily: {
                        meme: ['"Comic Sans MS"', '"Comic Neue"', 'cursive'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .text-shadow {
                text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3);
            }
            .glow {
                filter: drop-shadow(0 0 8px currentColor);
            }
            .rotate-random {
                transform: rotate(var(--rotation, -5deg));
            }
            .bounce-meme {
                animation: bounceMeme 0.5s ease-in-out infinite alternate;
            }
            @keyframes bounceMeme {
                from { transform: translateY(0); }
                to { transform: translateY(-10px); }
            }
            .wiggle {
                animation: wiggle 1s ease-in-out infinite;
            }
            @keyframes wiggle {
                0%, 100% { transform: rotate(-3deg); }
                50% { transform: rotate(3deg); }
            }
            
            .meme-pulse {
                animation: memePulse 2s ease-in-out infinite;
            }
            @keyframes memePulse {
                0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
                50% { transform: scale(1.05); filter: hue-rotate(180deg); }
            }
            
            .rainbow-text {
                animation: rainbow 3s linear infinite;
            }
            @keyframes rainbow {
                0% { color: #ff0000; }
                16.66% { color: #ff8000; }
                33.33% { color: #ffff00; }
                50% { color: #00ff00; }
                66.66% { color: #0080ff; }
                83.33% { color: #8000ff; }
                100% { color: #ff0000; }
            }
            
            .corpse-glow {
                animation: corpseGlow 1.5s ease-in-out infinite alternate;
            }
            @keyframes corpseGlow {
                from { filter: drop-shadow(0 0 5px currentColor); }
                to { filter: drop-shadow(0 0 20px currentColor); }
            }

        }
    </style>
</head>
<body class="bg-gray-900 font-meme min-h-screen flex flex-col items-center justify-center p-4 text-white overflow-x-hidden">
    <!-- 页面标题 -->
    <header class="text-center mb-6 relative">
        <h1 class="text-[clamp(2rem,5vw,4rem)] font-bold text-memeYellow glow mb-2 transform -rotate-2">
            <i class="fa fa-users mr-2"></i> 多人 MEME 贪吃蛇 <i class="fa fa-users ml-2"></i>
        </h1>
        <p class="text-memePink text-[clamp(1rem,2vw,1.5rem)] wiggle">
            和朋友一起吃，一起胖！
        </p>
    </header>

         <!-- 游戏容器 -->
     <main class="relative w-full max-w-6xl">
        <!-- 玩家信息和分数面板 -->
        <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-user text-memeBlue mr-2"></i>
                    <span class="text-xl">玩家: <span id="playerName" class="text-memeGreen font-bold">匿名玩家</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-star text-memeYellow mr-2"></i>
                    <span class="text-xl">分数: <span id="score" class="text-memeGreen font-bold">0</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-users text-memePink mr-2"></i>
                    <span class="text-xl">在线: <span id="playerCount" class="text-memeBlue font-bold">0</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-gamepad text-memeRed mr-2"></i>
                    <span class="text-xl">房间: <span id="roomName" class="text-memeBlue font-bold">默认房间</span></span>
                </div>
            </div>
        </div>
        
        <!-- 游戏画布容器 -->
        <div class="relative border-4 border-memePink rounded-lg overflow-hidden bg-gray-800 shadow-lg">
            <canvas id="gameCanvas" class="w-full h-auto bg-gray-900"></canvas>
            
            <!-- 开始屏幕 -->
            <div id="startScreen" class="absolute inset-0 bg-gray-900/90 flex flex-col items-center justify-center z-10">
                <h2 class="text-4xl font-bold text-memeYellow mb-6 bounce-meme">准备好和朋友一起玩了吗？</h2>
                <div class="mb-4 w-full max-w-xs">
                    <label for="playerNameInput" class="block text-left mb-2 text-memeGreen">你的昵称</label>
                    <input type="text" id="playerNameInput" 
                           class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme"
                           placeholder="输入你的名字">
                </div>
                <div class="mb-4 w-full max-w-xs">
                    <label for="roomSelect" class="block text-left mb-2 text-memeBlue">选择房间</label>
                    <select id="roomSelect" class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme">
                        <option value="default">默认房间</option>
                        <option value="room1">房间1 - 新手区</option>
                        <option value="room2">房间2 - 高手区</option>
                        <option value="room3">房间3 - 休闲区</option>
                    </select>
                </div>
                <div class="mb-6 w-full max-w-xs">
                    <label class="block text-left mb-2 text-memePink">选择颜色</label>
                    <div class="flex gap-2 flex-wrap">
                        <button class="color-btn w-8 h-8 rounded-full bg-memeRed border-2 border-white" data-color="#FF3333"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeBlue border-2" data-color="#0066FF"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeGreen border-2" data-color="#33CC33"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeYellow border-2" data-color="#FFE100"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memePink border-2" data-color="#FF66CC"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-orange-500 border-2" data-color="#FF9900"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-purple-500 border-2" data-color="#9966FF"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-cyan-500 border-2" data-color="#66CCFF"></button>
                    </div>
                </div>
                <button id="startBtn" class="bg-memeRed hover:bg-memeRed/80 text-white text-2xl py-3 px-8 rounded-full transform transition-transform hover:scale-110 active:scale-95 font-bold shadow-lg">
                    加入游戏 <i class="fa fa-play ml-2"></i>
                </button>
            </div>
            
            <!-- 游戏结束屏幕 -->
            <div id="gameOverScreen" class="absolute inset-0 bg-gray-900/95 flex flex-col items-center justify-center z-10 hidden">
                <h2 class="text-5xl font-bold text-memeRed mb-4 wiggle">游戏结束！</h2>
                <p class="text-2xl mb-2">你的分数: <span id="finalScore" class="text-memeGreen font-bold">0</span></p>
                <p class="text-xl mb-4">排行榜:</p>
                <ul id="leaderboard" class="mb-8 bg-gray-800 p-4 rounded-lg w-64">
                    <!-- 排行榜会在这里动态生成 -->
                </ul>
                <button id="restartBtn" class="bg-memeGreen hover:bg-memeGreen/80 text-white text-2xl py-3 px-8 rounded-full transform transition-transform hover:scale-110 active:scale-95 font-bold shadow-lg">
                    再来一局 <i class="fa fa-refresh ml-2"></i>
                </button>
            </div>
            
            <!-- 暂停按钮 -->
            <button id="pauseBtn" class="absolute top-4 right-4 bg-gray-800/70 hover:bg-gray-700 text-white p-2 rounded-full z-5 hidden">
                <i class="fa fa-pause text-xl"></i>
            </button>
            
            <!-- 房间切换按钮 -->
            <button id="roomSwitchBtn" class="absolute top-4 left-4 bg-gray-800/70 hover:bg-gray-700 text-white p-2 rounded-full z-5 hidden">
                <i class="fa fa-exchange text-xl"></i>
            </button>
        </div>
        
        <!-- 游戏控制和玩家列表 -->
        <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="bg-gray-800 p-4 rounded-lg border border-memeBlue">
                <h3 class="text-memeBlue text-xl font-bold mb-2">游戏说明</h3>
                <ul class="list-disc pl-5 space-y-1">
                    <li>吃掉食物让蛇变长</li>
                    <li>撞到墙壁、自己或其他玩家会死亡</li>
                    <li>分数越高，速度越快</li>
                    <li>吃到特殊食物有惊喜！</li>
                    <li>按空格键暂停/继续</li>
                </ul>
            </div>
            <div class="bg-gray-800 p-4 rounded-lg border border-memeGreen">
                <h3 class="text-memeGreen text-xl font-bold mb-2">当前玩家</h3>
                <ul id="playersList" class="space-y-2 max-h-32 overflow-y-auto">
                    <!-- 玩家列表会在这里动态生成 -->
                </ul>
            </div>
        </div>
        
        <!-- 房间统计 -->
        <div class="mt-4 bg-gray-800 p-4 rounded-lg border border-memeYellow">
            <h3 class="text-memeYellow text-xl font-bold mb-2">房间统计</h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeGreen" id="totalPlayers">0</div>
                    <div class="text-sm text-gray-400">总玩家数</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeBlue" id="activePlayers">0</div>
                    <div class="text-sm text-gray-400">活跃玩家</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeRed" id="roomHighScore">0</div>
                    <div class="text-sm text-gray-400">房间最高分</div>
                </div>
            </div>
        </div>
        

    </main>
    
    <!-- 页脚 -->
    <footer class="mt-8 text-center text-gray-500 text-sm">
        <p>© 2023 多人联机 Meme 贪吃蛇 | 用 Firebase 实时同步 <i class="fa fa-bolt text-memeYellow"></i></p>
    </footer>

    <script>
        // Firebase 配置
        const firebaseConfig = {
            apiKey: "AIzaSyA5Z5ieEbAcfQX0kxGSn9ldGXhzvAwx_8M",
            authDomain: "chat-294cc.firebaseapp.com",
            databaseURL: "https://chat-294cc-default-rtdb.firebaseio.com",
            projectId: "chat-294cc",
            storageBucket: "chat-294cc.firebasestorage.app",
            messagingSenderId: "913615304269",
            appId: "1:913615304269:web:0274ffaccb8e6b678e4e04",
            measurementId: "G-SJR9NDW86B"
        };

        // 初始化 Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
        // 游戏常量和变量
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const playerCountElement = document.getElementById('playerCount');
        const playerNameElement = document.getElementById('playerName');
        const finalScoreElement = document.getElementById('finalScore');
        const leaderboardElement = document.getElementById('leaderboard');
        const playersListElement = document.getElementById('playersList');
        const roomNameElement = document.getElementById('roomName');
        const totalPlayersElement = document.getElementById('totalPlayers');
        const activePlayersElement = document.getElementById('activePlayers');
        const roomHighScoreElement = document.getElementById('roomHighScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const roomSwitchBtn = document.getElementById('roomSwitchBtn');
        const playerNameInput = document.getElementById('playerNameInput');
        const roomSelect = document.getElementById('roomSelect');
        
        // 游戏状态变量
        let playerId = null;
        let playerName = '匿名玩家';
        let snake = [];
        let otherPlayers = {};
        let foods = []; // 改为数组存储多个食物
        let specialFood = null;
        let corpseFoods = []; // 死亡玩家的蛇身体变成的食物
        let direction = '';
        let nextDirection = '';
        let score = 0;
        let level = 1;
                 let gameSpeed = 120; // 毫秒，稍微加快速度适应更大的游戏区域
        let gameLoop;
        let isGameRunning = false;
        let isPaused = false;
        let gameRoom = 'default'; // 游戏房间
        let playerColor = '';
        let playerAvatar = '';
        let gameMargin = 0; // 游戏边距（包边）
        const MAX_FOODS = 5; // 场上最多食物数量
        
        // Meme元素
        const memeFaces = ['(◍•ᴗ•◍)', '(¬‿¬)', '(ʘ‿ʘ)', '(◔_◔)', '(°ロ°)'];
        const memeColors = [
            '#FFE100', '#0066FF', '#FF3333', '#33CC33', '#FF66CC',
            '#FF9900', '#9966FF', '#66CCFF', '#FF6666', '#99FF66'
        ];
        
                 // 设置画布尺寸
         function resizeCanvas() {
             const container = canvas.parentElement;
             // 增加画布尺寸，让游戏区域更大
             canvas.width = Math.min(container.clientWidth, 1200); // 最大宽度1200px
             canvas.height = Math.min(container.clientWidth * 0.8, 960); // 最大高度960px，保持4:5比例
             
             // 计算边距（包边）
             const margin = Math.floor(canvas.width * 0.05); // 5%的边距
             gameMargin = margin;
         }
        
        // 初始化时调整尺寸，并监听窗口大小变化
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 生成唯一玩家ID
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substring(2, 10);
        }
        
        // 初始化游戏
        function initGame() {
            // 生成玩家ID
            playerId = generatePlayerId();
            
            // 获取玩家名称和房间
            if (playerNameInput.value.trim()) {
                playerName = playerNameInput.value.trim();
            }
            gameRoom = roomSelect.value;
            playerNameElement.textContent = playerName;
            
            // 更新房间名称显示
            const roomNames = {
                'default': '默认房间',
                'room1': '房间1 - 新手区',
                'room2': '房间2 - 高手区',
                'room3': '房间3 - 休闲区'
            };
            roomNameElement.textContent = roomNames[gameRoom] || '默认房间';
            
                                     // 设置初始蛇位置
            const gridSize = Math.floor(canvas.width / 40); // 减小网格大小，增加移动范围
            
            // 计算有效游戏区域的网格数量（考虑边距）
            const effectiveWidth = canvas.width - 2 * gameMargin;
            const effectiveHeight = canvas.height - 2 * gameMargin;
            const gridCols = Math.floor(effectiveWidth / gridSize);
            const gridRows = Math.floor(effectiveHeight / gridSize);
            
            // 定义出生点（使用网格坐标，在有效区域内）
            const spawnPoints = [
                {gridX: 5, gridY: 5},
                {gridX: gridCols - 5, gridY: 5},
                {gridX: 5, gridY: gridRows - 5},
                {gridX: gridCols - 5, gridY: gridRows - 5}
            ];
            const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            
            // 转换为像素坐标（加上边距偏移）
            const pixelX = gameMargin + spawnPoint.gridX * gridSize;
            const pixelY = gameMargin + spawnPoint.gridY * gridSize;
            
                                     snake = [
                { x: pixelX, y: pixelY },
                { x: pixelX - gridSize, y: pixelY },
                { x: pixelX - gridSize * 2, y: pixelY },
                { x: pixelX - gridSize * 3, y: pixelY }
            ];
            
            // 初始方向
            direction = 'right';
            nextDirection = 'right';
            
                         // 重置分数和等级
             score = 0;
             level = 1;
             gameSpeed = 120; // 稍微加快速度适应更大的游戏区域
            
            // 更新UI
            updateScore();
            
            // 保存玩家信息到Firebase
            savePlayerInfo();
            
            // 监听其他玩家和食物
            listenForGameUpdates();
            
            // 初始生成食物（如果不存在）
            database.ref(`rooms/${gameRoom}/foods`).once('value', (snapshot) => {
                if (!snapshot.exists() || !snapshot.val() || snapshot.val().length === 0) {
                    generateInitialFoods();
                }
            });
            
            // 绘制初始状态
            draw();
        }
        
        // 保存玩家信息到Firebase
        function savePlayerInfo() {
            const playerRef = database.ref(`rooms/${gameRoom}/players/${playerId}`);
            
            // 设置玩家初始信息
            playerRef.set({
                name: playerName,
                snake: snake,
                direction: direction,
                score: score,
                alive: true,
                color: playerColor || memeColors[Math.floor(Math.random() * memeColors.length)],
                room: gameRoom,
                lastActive: Date.now()
            });
            
            // 当页面关闭时移除玩家
            window.addEventListener('beforeunload', () => {
                playerRef.remove();
            });
            
            // 定期更新最后活动时间
            setInterval(() => {
                if (isGameRunning && !isPaused) {
                    playerRef.update({
                        lastActive: Date.now()
                    });
                }
            }, 5000);
        }
        
        // 监听游戏更新
        function listenForGameUpdates() {
            // 监听其他玩家
            database.ref(`rooms/${gameRoom}/players`).on('value', (snapshot) => {
                const players = snapshot.val() || {};
                otherPlayers = {};
                
                // 更新玩家列表
                playersListElement.innerHTML = '';
                playerCountElement.textContent = Object.keys(players).length;
                
                let activeCount = 0;
                Object.keys(players).forEach(id => {
                    if (id !== playerId && players[id].alive) {
                        otherPlayers[id] = players[id];
                        activeCount++;
                    }
                    
                    // 添加到玩家列表
                    const li = document.createElement('li');
                    li.className = id === playerId ? 'text-memeGreen font-bold' : '';
                    li.innerHTML = `<span style="color: ${players[id].color}">●</span> ${players[id].name} (${players[id].score})`;
                    playersListElement.appendChild(li);
                });
                
                // 更新统计信息
                totalPlayersElement.textContent = Object.keys(players).length;
                activePlayersElement.textContent = activeCount + (isGameRunning ? 1 : 0);
                
                // 更新排行榜
                updateLeaderboard(players);
            });
            
            // 监听食物
            database.ref(`rooms/${gameRoom}/foods`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    foods = snapshot.val() || [];
                } else {
                    foods = [];
                }
            });
            
            // 监听特殊食物
            database.ref(`rooms/${gameRoom}/specialFood`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    specialFood = snapshot.val();
                } else {
                    specialFood = null;
                }
            });
            
            // 监听尸体食物
            database.ref(`rooms/${gameRoom}/corpseFoods`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    corpseFoods = snapshot.val() || [];
                } else {
                    corpseFoods = [];
                }
            });
            
            // 监听房间最高分
            database.ref(`rooms/${gameRoom}/highScores`).on('value', (snapshot) => {
                const highScores = snapshot.val() || {};
                let maxScore = 0;
                
                Object.values(highScores).forEach(score => {
                    if (score.score > maxScore) {
                        maxScore = score.score;
                    }
                });
                
                roomHighScoreElement.textContent = maxScore;
            });
        }
        
        // 更新排行榜
        function updateLeaderboard(players) {
            leaderboardElement.innerHTML = '';
            
            // 排序玩家
            const sortedPlayers = Object.values(players)
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
            
            sortedPlayers.forEach((player, index) => {
                const li = document.createElement('li');
                li.className = index === 0 ? 'text-memeYellow font-bold' : 
                              index === 1 ? 'text-gray-300' : 
                              index === 2 ? 'text-amber-700' : '';
                li.innerHTML = `${index + 1}. ${player.name} - ${player.score}分`;
                leaderboardElement.appendChild(li);
            });
        }
        

        
        // 生成初始食物（生成多个食物）
        function generateInitialFoods() {
            const gridSize = Math.floor(canvas.width / 40);
            const foodsToGenerate = Math.min(MAX_FOODS, 3); // 初始生成3个食物
            
            database.ref(`rooms/${gameRoom}/players`).once('value', (snapshot) => {
                const players = snapshot.val() || {};
                const newFoods = [];
                
                for (let i = 0; i < foodsToGenerate; i++) {
                    const newFood = generateSingleFood(players, newFoods);
                    if (newFood) {
                        newFoods.push(newFood);
                    }
                }
                
                // 保存所有食物到Firebase
                database.ref(`rooms/${gameRoom}/foods`).set(newFoods);
            });
        }
        
        // 生成单个食物
        function generateSingleFood(players, existingFoods = []) {
            const gridSize = Math.floor(canvas.width / 40);
            let attempts = 0;
            const maxAttempts = 100;
            
            while (attempts < maxAttempts) {
                attempts++;
                // 计算有效游戏区域的网格数量（考虑边距）
                const effectiveWidth = canvas.width - 2 * gameMargin;
                const effectiveHeight = canvas.height - 2 * gameMargin;
                const gridCols = Math.floor(effectiveWidth / gridSize);
                const gridRows = Math.floor(effectiveHeight / gridSize);
                
                // 生成随机网格坐标（在有效区域内）
                const gridX = Math.floor(Math.random() * gridCols);
                const gridY = Math.floor(Math.random() * gridRows);
                
                // 转换为像素坐标（加上边距偏移）
                const pixelX = gameMargin + gridX * gridSize;
                const pixelY = gameMargin + gridY * gridSize;
                
                const newFood = {
                    x: pixelX,
                    y: pixelY,
                    color: memeColors[Math.floor(Math.random() * memeColors.length)],
                    meme: memeFaces[Math.floor(Math.random() * memeFaces.length)],
                    timestamp: Date.now(),
                    id: 'food_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9)
                };
                
                let validPosition = true;
                
                // 检查是否与当前玩家蛇身重叠
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
                
                if (!validPosition) continue;
                
                // 检查是否与其他玩家蛇身重叠
                Object.values(players).forEach(player => {
                    if (player.snake && player.alive) {
                        for (let segment of player.snake) {
                            if (segment.x === newFood.x && segment.y === newFood.y) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    if (!validPosition) return;
                });
                
                // 检查是否与现有食物重叠
                existingFoods.forEach(food => {
                    if (food.x === newFood.x && food.y === newFood.y) {
                        validPosition = false;
                    }
                });
                
                // 检查是否与尸体食物重叠
                if (corpseFoods && corpseFoods.length > 0) {
                    corpseFoods.forEach(corpseFood => {
                        if (corpseFood.x === newFood.x && corpseFood.y === newFood.y) {
                            validPosition = false;
                        }
                    });
                }
                
                if (validPosition) {
                    return newFood;
                }
            }
            
            // 如果找不到有效位置，返回null
            return null;
        }
        
        // 生成普通食物（当食物被吃掉时调用）
        function generateFood() {
            const gridSize = Math.floor(canvas.width / 40);
            
            // 确保食物不会出现在任何蛇身上
            database.ref(`rooms/${gameRoom}/players`).once('value', (snapshot) => {
                const players = snapshot.val() || {};
                
                // 获取当前食物列表
                database.ref(`rooms/${gameRoom}/foods`).once('value', (foodsSnapshot) => {
                    const currentFoods = foodsSnapshot.val() || [];
                    
                    // 如果当前食物数量少于最大数量，生成新食物
                    if (currentFoods.length < MAX_FOODS) {
                        const newFood = generateSingleFood(players, currentFoods);
                        if (newFood) {
                            currentFoods.push(newFood);
                            database.ref(`rooms/${gameRoom}/foods`).set(currentFoods);
                        }
                    }
                });
            });
        }
        
                         // 生成特殊食物
        function generateSpecialFood() {
            const gridSize = Math.floor(canvas.width / 40);
            let newFood;
            
            // 确保特殊食物不会出现在任何蛇身上或普通食物位置
            database.ref(`rooms/${gameRoom}/players`).once('value', (playersSnapshot) => {
                database.ref(`rooms/${gameRoom}/foods`).once('value', (foodsSnapshot) => {
                    const players = playersSnapshot.val() || {};
                    const currentFoods = foodsSnapshot.val() || [];
                    let validPosition = false;
                    
                    while (!validPosition) {
                        // 计算有效游戏区域的网格数量（考虑边距）
                        const effectiveWidth = canvas.width - 2 * gameMargin;
                        const effectiveHeight = canvas.height - 2 * gameMargin;
                        const gridCols = Math.floor(effectiveWidth / gridSize);
                        const gridRows = Math.floor(effectiveHeight / gridSize);
                        
                        // 生成随机网格坐标（在有效区域内）
                        const gridX = Math.floor(Math.random() * gridCols);
                        const gridY = Math.floor(Math.random() * gridRows);
                        
                        // 转换为像素坐标（加上边距偏移）
                        const pixelX = gameMargin + gridX * gridSize;
                        const pixelY = gameMargin + gridY * gridSize;
                        
                        newFood = {
                            x: pixelX,
                            y: pixelY,
                            color: '#FFFFFF',
                            meme: '✨',
                            timestamp: Date.now(),
                            timer: 50 // 存在50个游戏帧
                        };
                        
                        validPosition = true;
                        
                        // 检查是否与普通食物重叠
                        currentFoods.forEach(food => {
                            if (food.x === newFood.x && food.y === newFood.y) {
                                validPosition = false;
                            }
                        });
                        
                        if (!validPosition) continue;
                        
                        // 检查是否与尸体食物重叠
                        if (corpseFoods && corpseFoods.length > 0) {
                            corpseFoods.forEach(corpseFood => {
                                if (corpseFood.x === newFood.x && corpseFood.y === newFood.y) {
                                    validPosition = false;
                                }
                            });
                        }
                        
                        if (!validPosition) continue;
                        
                        // 检查是否与当前玩家蛇身重叠
                        for (let segment of snake) {
                            if (segment.x === newFood.x && segment.y === newFood.y) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        if (!validPosition) continue;
                        
                        // 检查是否与其他玩家蛇身重叠
                        Object.values(players).forEach(player => {
                            if (player.snake && player.alive) {
                                for (let segment of player.snake) {
                                    if (segment.x === newFood.x && segment.y === newFood.y) {
                                        validPosition = false;
                                        break;
                                    }
                                }
                            }
                            if (!validPosition) return;
                        });
                    }
                    
                    // 保存特殊食物到Firebase
                    database.ref(`rooms/${gameRoom}/specialFood`).set(newFood);
                    
                    // 5秒后移除特殊食物
                    setTimeout(() => {
                        database.ref(`rooms/${gameRoom}/specialFood`).once('value', (snapshot) => {
                            if (snapshot.exists() && snapshot.val().timestamp === newFood.timestamp) {
                                database.ref(`rooms/${gameRoom}/specialFood`).remove();
                            }
                        });
                    }, 5000);
                });
            });
        }
        
        // 更新分数
        function updateScore() {
            scoreElement.textContent = score;
            finalScoreElement.textContent = score;
            
            // 更新Firebase中的分数
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    score: score
                });
            }
        }
        
                         // 检查碰撞
        function checkCollision() {
            const head = snake[0];
            const gridSize = Math.floor(canvas.width / 40); // 减小网格大小，增加移动范围
            
            // 检查墙壁碰撞（考虑边距）
            if (head.x < gameMargin || head.x >= canvas.width - gameMargin || 
                head.y < gameMargin || head.y >= canvas.height - gameMargin) {
                return true;
            }
            
            // 检查自身碰撞
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            
            // 检查与其他玩家碰撞（包括死亡玩家的蛇身体）
            Object.values(otherPlayers).forEach(player => {
                if (player.snake) {
                    for (let segment of player.snake) {
                        if (head.x === segment.x && head.y === segment.y) {
                            return true;
                        }
                    }
                }
            });
            
            return false;
        }
        
        // 检查食物碰撞
        function checkFoodCollision() {
            const head = snake[0];
            const gridSize = Math.floor(canvas.width / 40);
            let ateFood = false;
            
            // 检查普通食物碰撞
            if (foods && foods.length > 0) {
                for (let i = 0; i < foods.length; i++) {
                    const food = foods[i];
                    
                    // 调试信息：显示蛇头和食物的坐标
                    console.log('碰撞检测:', {
                        head: {x: head.x, y: head.y},
                        food: {x: food.x, y: food.y},
                        gridSize: gridSize,
                        distance: Math.sqrt(Math.pow(head.x - food.x, 2) + Math.pow(head.y - food.y, 2))
                    });
                    
                    // 使用更宽松的碰撞检测
                    if (Math.abs(head.x - food.x) < gridSize/2 && Math.abs(head.y - food.y) < gridSize/2) {
                        console.log('吃到普通食物!', {head, food}); // 调试信息
                        
                        // 增加分数
                        score += 10;
                        
                        // 每100分升级
                        if (score % 100 === 0) {
                            level++;
                            // 加快游戏速度，最低50ms
                            gameSpeed = Math.max(50, gameSpeed - 10);
                            // 重新设置游戏循环速度
                            if (isGameRunning && !isPaused) {
                                clearInterval(gameLoop);
                                gameLoop = setInterval(gameUpdate, gameSpeed);
                            }
                        }
                        
                        updateScore();
                        
                        // 移除被吃掉的食物
                        const updatedFoods = foods.filter((_, index) => index !== i);
                        database.ref(`rooms/${gameRoom}/foods`).set(updatedFoods);
                        
                        // 生成新食物
                        generateFood();
                        
                        // 有10%的几率生成特殊食物
                        if (Math.random() < 0.1) {
                            generateSpecialFood();
                        }
                        
                        ateFood = true;
                        break; // 一次只能吃一个食物
                    }
                }
            }
            
            // 检查尸体食物碰撞
            if (corpseFoods && corpseFoods.length > 0) {
                for (let i = 0; i < corpseFoods.length; i++) {
                    const corpseFood = corpseFoods[i];
                    
                    // 使用更宽松的碰撞检测
                    if (Math.abs(head.x - corpseFood.x) < gridSize/2 && Math.abs(head.y - corpseFood.y) < gridSize/2) {
                        console.log('吃到尸体食物!', {head, corpseFood}); // 调试信息
                        
                        // 尸体食物只加分数，不增加蛇长度
                        score += 5;
                        updateScore();
                        
                        // 移除被吃掉的尸体食物
                        const updatedCorpseFoods = corpseFoods.filter((_, index) => index !== i);
                        database.ref(`rooms/${gameRoom}/corpseFoods`).set(updatedCorpseFoods);
                        
                        // 注意：不吃尸体食物，所以不设置ateFood = true
                        break; // 一次只能吃一个食物
                    }
                }
            }
            
            // 特殊食物 - 使用更宽松的碰撞检测
            if (specialFood && Math.abs(head.x - specialFood.x) < gridSize/2 && Math.abs(head.y - specialFood.y) < gridSize/2) {
                console.log('吃到特殊食物!', {head, specialFood}); // 调试信息
                
                // 特殊食物给更多分数
                score += 50;
                updateScore();
                database.ref(`rooms/${gameRoom}/specialFood`).remove();
                ateFood = true;
            }
            
            return ateFood;
        }
        
        // 更新游戏状态
        function gameUpdate() {
            if (isPaused) return;
            
                         // 更新方向
             direction = nextDirection;
             
             const gridSize = Math.floor(canvas.width / 40); // 减小网格大小，增加移动范围
            const head = { x: snake[0].x, y: snake[0].y };
            
            // 根据方向移动蛇头
            switch (direction) {
                case 'up':
                    head.y -= gridSize;
                    break;
                case 'down':
                    head.y += gridSize;
                    break;
                case 'left':
                    head.x -= gridSize;
                    break;
                case 'right':
                    head.x += gridSize;
                    break;
            }
            
            // 将新头部添加到蛇
            snake.unshift(head);
            
            // 检查是否吃到食物
            const ateFood = checkFoodCollision();
            
            // 如果没吃到食物，移除尾部
            if (!ateFood) {
                snake.pop();
            }
            
            // 检查碰撞
            if (checkCollision()) {
                gameOver();
                return;
            }
            
            // 更新Firebase中的蛇状态
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    snake: snake,
                    direction: direction
                });
            }
            
            // 绘制游戏
            draw();
        }
        
                 // 绘制游戏
         function draw() {
             const gridSize = Math.floor(canvas.width / 40); // 减小网格大小，增加移动范围
            
            // 清空画布
            ctx.fillStyle = '#121212';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制边距区域（包边）
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, gameMargin); // 上边距
            ctx.fillRect(0, canvas.height - gameMargin, canvas.width, gameMargin); // 下边距
            ctx.fillRect(0, 0, gameMargin, canvas.height); // 左边距
            ctx.fillRect(canvas.width - gameMargin, 0, gameMargin, canvas.height); // 右边距
            
            // 绘制网格背景（仅在有效游戏区域内）
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            
            // 只在有效游戏区域内绘制网格
            for (let x = gameMargin; x < canvas.width - gameMargin; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, gameMargin);
                ctx.lineTo(x, canvas.height - gameMargin);
                ctx.stroke();
            }
            
            for (let y = gameMargin; y < canvas.height - gameMargin; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(gameMargin, y);
                ctx.lineTo(canvas.width - gameMargin, y);
                ctx.stroke();
            }
            
            // 绘制其他玩家的蛇
            Object.values(otherPlayers).forEach(player => {
                if (player.snake) {
                    player.snake.forEach((segment, index) => {
                        // 蛇头特殊样式
                        if (index === 0) {
                            // 蛇头背景
                            ctx.fillStyle = player.color;
                            ctx.shadowColor = player.color;
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            
                            // 蛇头表情
                            ctx.fillStyle = 'white';
                            ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('😜', segment.x + gridSize / 2, segment.y + gridSize / 2);
                            
                            // 玩家名称标签
                            ctx.fillStyle = player.color;
                            ctx.font = `${gridSize * 0.4}px "Comic Sans MS", cursive`;
                            ctx.fillText(player.name, segment.x + gridSize / 2, segment.y - 10);
                        } else {
                            // 蛇身
                            ctx.fillStyle = player.color;
                            
                            // 蛇身随机旋转
                            const rotation = (Math.sin(index * 0.5) * 10);
                            
                            ctx.save();
                            ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                            ctx.rotate(rotation * Math.PI / 180);
                            
                            // 蛇身形状
                            ctx.beginPath();
                            ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.restore();
                        }
                    });
                }
            });
            
            // 绘制自己的蛇
            snake.forEach((segment, index) => {
                // 蛇头特殊样式
                if (index === 0) {
                    // 蛇头背景
                    ctx.fillStyle = '#FF3333';
                    ctx.shadowColor = '#FF3333';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // 蛇头表情
                    ctx.fillStyle = 'white';
                    ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('😛', segment.x + gridSize / 2, segment.y + gridSize / 2);
                    
                    // 自己的名称标签
                    ctx.fillStyle = '#FF3333';
                    ctx.font = `${gridSize * 0.4}px "Comic Sans MS", cursive`;
                    ctx.fillText(playerName, segment.x + gridSize / 2, segment.y - 10);
                } else {
                    // 蛇身使用随机meme颜色
                    const colorIndex = (index % memeColors.length);
                    ctx.fillStyle = memeColors[colorIndex];
                    
                    // 蛇身随机旋转
                    const rotation = (Math.sin(index * 0.5) * 10);
                    
                    ctx.save();
                    ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                    ctx.rotate(rotation * Math.PI / 180);
                    
                                            // 蛇身形状
                        ctx.beginPath();
                        ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    
                    ctx.restore();
                }
            });
            
                         // 绘制普通食物
             if (foods && foods.length > 0) {
                 foods.forEach(food => {
                     ctx.fillStyle = food.color;
                     ctx.shadowColor = food.color;
                     ctx.shadowBlur = 10;
                     ctx.beginPath();
                     ctx.arc(food.x + gridSize / 2, food.y + gridSize / 2, gridSize / 2, 0, Math.PI * 2);
                     ctx.fill();
                     ctx.shadowBlur = 0;
                     
                     // 食物上的meme表情
                     ctx.fillStyle = 'black';
                     ctx.font = `${gridSize * 0.5}px "Comic Sans MS", cursive`;
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.fillText(food.meme, food.x + gridSize / 2, food.y + gridSize / 2);
                 });
             }
            
                         // 绘制尸体食物
             if (corpseFoods && corpseFoods.length > 0) {
                 corpseFoods.forEach(corpseFood => {
                     // 保存当前上下文
                     ctx.save();
                     
                     // 计算动画效果
                     const time = Date.now() / 1000;
                     const pulseScale = 1 + Math.sin(time * (corpseFood.pulse || 2)) * 0.1;
                     const wiggleOffset = Math.sin(time * 3) * (corpseFood.wiggle || 3);
                     const rotation = (corpseFood.rotation || 0) + Math.sin(time * 2) * 10;
                     
                     // 设置变换
                     ctx.translate(corpseFood.x + gridSize / 2 + wiggleOffset, corpseFood.y + gridSize / 2);
                     ctx.rotate(rotation * Math.PI / 180);
                     ctx.scale(pulseScale, pulseScale);
                     
                     // 绘制发光背景
                     const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gridSize / 2);
                     gradient.addColorStop(0, corpseFood.color);
                     gradient.addColorStop(0.7, corpseFood.color + '80');
                     gradient.addColorStop(1, 'transparent');
                     
                     ctx.fillStyle = gradient;
                     ctx.shadowColor = corpseFood.color;
                     ctx.shadowBlur = 20;
                     ctx.beginPath();
                     ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                     ctx.fill();
                     
                     // 绘制边框
                     ctx.strokeStyle = '#FFFFFF';
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.arc(0, 0, gridSize / 2 - 2, 0, Math.PI * 2);
                     ctx.stroke();
                     
                     // 重置阴影
                     ctx.shadowBlur = 0;
                     
                     // 绘制meme表情
                     ctx.fillStyle = '#FFFFFF';
                     ctx.font = `bold ${gridSize * 0.6}px "Comic Sans MS", cursive`;
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.fillText(corpseFood.meme, 0, 0);
                     
                     // 恢复上下文
                     ctx.restore();
                     
                     // 显示死亡玩家的名字（带特效）
                     ctx.save();
                     ctx.translate(corpseFood.x + gridSize / 2, corpseFood.y - 20);
                     
                     // 名字背景
                     ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                     ctx.beginPath();
                     ctx.moveTo(-30, -10);
                     ctx.lineTo(30, -10);
                     ctx.lineTo(30, 10);
                     ctx.lineTo(-30, 10);
                     ctx.closePath();
                     ctx.fill();
                     
                     // 名字文字
                     ctx.fillStyle = corpseFood.originalColor;
                     ctx.font = `bold ${gridSize * 0.25}px "Comic Sans MS", cursive`;
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.shadowColor = '#000000';
                     ctx.shadowBlur = 2;
                     ctx.fillText(corpseFood.playerName, 0, 0);
                     
                     ctx.restore();
                 });
             }
             
             // 绘制特殊食物（闪烁效果）
             if (specialFood) {
                 // 闪烁效果
                 const opacity = 0.5 + Math.sin(Date.now() / 100) * 0.5;
                 
                 ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                 ctx.shadowColor = 'white';
                 ctx.shadowBlur = 20;
                 
                 // 旋转动画
                 ctx.save();
                 ctx.translate(specialFood.x + gridSize / 2, specialFood.y + gridSize / 2);
                 ctx.rotate(Date.now() / 500);
                 
                 ctx.beginPath();
                 ctx.rect(-gridSize / 2, -gridSize / 2, gridSize, gridSize);
                 ctx.fill();
                 
                 // 特殊符号
                 ctx.fillStyle = 'gold';
                 ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText(specialFood.meme, 0, 0);
                 
                 ctx.restore();
                 ctx.shadowBlur = 0;
             }
        }
        
        // 开始游戏
        function startGame() {
            if (isGameRunning) return;
            
            startScreen.classList.add('hidden');
            pauseBtn.classList.remove('hidden');
            roomSwitchBtn.classList.remove('hidden');
            isGameRunning = true;
            isPaused = false;
            
            // 初始化游戏
            initGame();
            
            // 启动游戏循环
            gameLoop = setInterval(gameUpdate, gameSpeed);
        }
        
        // 切换房间
        function switchRoom() {
            if (!isGameRunning) return;
            
            // 暂停游戏
            isPaused = true;
            
            // 移除当前房间的玩家数据
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).remove();
            }
            
            // 显示房间选择
            startScreen.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            roomSwitchBtn.classList.add('hidden');
            
            // 停止游戏循环
            clearInterval(gameLoop);
            isGameRunning = false;
            

        }
        
        // 暂停/继续游戏
        function togglePause() {
            if (!isGameRunning) return;
            
            isPaused = !isPaused;
            pauseBtn.innerHTML = isPaused ? 
                '<i class="fa fa-play text-xl"></i>' : 
                '<i class="fa fa-pause text-xl"></i>';
        }
        
        // 游戏结束
        function gameOver() {
            clearInterval(gameLoop);
            isGameRunning = false;
            gameOverScreen.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            
            // 将死亡的蛇身体变成尸体食物
            createCorpseFoods();
            
            // 更新玩家状态为死亡
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    alive: false
                });
            }
            
            // 保存最高分
            saveHighScore();
        }
        
        // 创建尸体食物
        function createCorpseFoods() {
            if (snake && snake.length > 0) {
                const gridSize = Math.floor(canvas.width / 40);
                const newCorpseFoods = [];
                
                // 随机选择meme表情
                const memeEmojis = ['💀', '☠️', '👻', '🤡', '😵', '💩', '🔥', '⚰️', '🪦', '🧟'];
                const memeColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];
                
                // 将蛇身体的每个部分变成尸体食物
                snake.forEach((segment, index) => {
                    const randomMeme = memeEmojis[Math.floor(Math.random() * memeEmojis.length)];
                    const randomColor = memeColors[Math.floor(Math.random() * memeColors.length)];
                    
                    const corpseFood = {
                        x: segment.x,
                        y: segment.y,
                        color: randomColor, // 随机meme颜色
                        meme: randomMeme,
                        timestamp: Date.now(),
                        id: 'corpse_' + Date.now() + '_' + index,
                        playerName: playerName,
                        originalColor: playerColor || '#FF3333',
                        rotation: Math.random() * 360, // 随机旋转角度
                        pulse: Math.random() * 2 + 1, // 随机脉冲速度
                        wiggle: Math.random() * 10 - 5 // 随机摆动幅度
                    };
                    newCorpseFoods.push(corpseFood);
                });
                
                // 获取现有的尸体食物并添加新的
                database.ref(`rooms/${gameRoom}/corpseFoods`).once('value', (snapshot) => {
                    const existingCorpseFoods = snapshot.val() || [];
                    const allCorpseFoods = [...existingCorpseFoods, ...newCorpseFoods];
                    database.ref(`rooms/${gameRoom}/corpseFoods`).set(allCorpseFoods);
                });
            }
        }
        
        // 保存最高分
        function saveHighScore() {
            const highScoreRef = database.ref(`rooms/${gameRoom}/highScores/${playerId}`);
            highScoreRef.once('value', (snapshot) => {
                const currentHigh = snapshot.val() || 0;
                if (score > currentHigh) {
                    highScoreRef.set({
                        playerName: playerName,
                        score: score,
                        timestamp: Date.now()
                    });
                }
            });
        }
        
        // 重启游戏
        function restartGame() {
            // 移除旧玩家数据
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).remove();
            }
            
            gameOverScreen.classList.add('hidden');
            startGame();
        }
        
        // 处理键盘输入
        function handleKeyPress(e) {
            // 阻止方向键滚动页面
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            
            // 只在游戏运行时处理方向键
            if (!isGameRunning && e.key !== ' ') return;
            
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction !== 'down') {
                        nextDirection = 'up';
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction !== 'up') {
                        nextDirection = 'down';
                    }
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction !== 'right') {
                        nextDirection = 'left';
                    }
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction !== 'left') {
                        nextDirection = 'right';
                    }
                    break;
                case ' ': // 空格键暂停/继续
                    if (isGameRunning) {
                        togglePause();
                    } else if (!startScreen.classList.contains('hidden')) {
                        startGame();
                    }
                    break;
            }
        }
        
        // 事件监听
        document.addEventListener('keydown', handleKeyPress);
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', restartGame);
        pauseBtn.addEventListener('click', togglePause);
        roomSwitchBtn.addEventListener('click', switchRoom);
        
        // 颜色选择
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // 移除其他按钮的选中状态
                document.querySelectorAll('.color-btn').forEach(b => {
                    b.classList.remove('border-white');
                    b.classList.add('border-gray-600');
                });
                
                // 选中当前按钮
                btn.classList.remove('border-gray-600');
                btn.classList.add('border-white');
                
                // 保存选择的颜色
                playerColor = btn.dataset.color;
            });
        });
        
        // 预填充一个搞笑的玩家名
        playerNameInput.value = ['贪吃蛇王', '专业吃货', '蛇蛇果实能力者', ' memes大师'][Math.floor(Math.random() * 4)];
        
        // 默认选择第一个颜色
        document.querySelector('.color-btn').click();
    </script>
</body>
</html>
