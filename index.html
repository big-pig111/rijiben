<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šäººè”æœº Meme è´ªåƒè›‡</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    
    <!-- é…ç½®Tailwindè‡ªå®šä¹‰é¢œè‰²å’Œå­—ä½“ -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        memeYellow: '#FFE100',
                        memeBlue: '#0066FF',
                        memeRed: '#FF3333',
                        memeGreen: '#33CC33',
                        memePink: '#FF66CC',
                    },
                    fontFamily: {
                        meme: ['"Comic Sans MS"', '"Comic Neue"', 'cursive'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .text-shadow {
                text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3);
            }
            .glow {
                filter: drop-shadow(0 0 8px currentColor);
            }
            .rotate-random {
                transform: rotate(var(--rotation, -5deg));
            }
            .bounce-meme {
                animation: bounceMeme 0.5s ease-in-out infinite alternate;
            }
            @keyframes bounceMeme {
                from { transform: translateY(0); }
                to { transform: translateY(-10px); }
            }
            .wiggle {
                animation: wiggle 1s ease-in-out infinite;
            }
            @keyframes wiggle {
                0%, 100% { transform: rotate(-3deg); }
                50% { transform: rotate(3deg); }
            }
            
            .meme-pulse {
                animation: memePulse 2s ease-in-out infinite;
            }
            @keyframes memePulse {
                0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
                50% { transform: scale(1.05); filter: hue-rotate(180deg); }
            }
            
            .rainbow-text {
                animation: rainbow 3s linear infinite;
            }
            @keyframes rainbow {
                0% { color: #ff0000; }
                16.66% { color: #ff8000; }
                33.33% { color: #ffff00; }
                50% { color: #00ff00; }
                66.66% { color: #0080ff; }
                83.33% { color: #8000ff; }
                100% { color: #ff0000; }
            }
            
            .corpse-glow {
                animation: corpseGlow 1.5s ease-in-out infinite alternate;
            }
            @keyframes corpseGlow {
                from { filter: drop-shadow(0 0 5px currentColor); }
                to { filter: drop-shadow(0 0 20px currentColor); }
            }

        }
    </style>
</head>
<body class="bg-gray-900 font-meme min-h-screen flex flex-col items-center justify-center p-4 text-white overflow-x-hidden">
    <!-- é¡µé¢æ ‡é¢˜ -->
    <header class="text-center mb-6 relative">
        <h1 class="text-[clamp(2rem,5vw,4rem)] font-bold text-memeYellow glow mb-2 transform -rotate-2">
            <i class="fa fa-users mr-2"></i> å¤šäºº MEME è´ªåƒè›‡ <i class="fa fa-users ml-2"></i>
        </h1>
        <p class="text-memePink text-[clamp(1rem,2vw,1.5rem)] wiggle">
            å’Œæœ‹å‹ä¸€èµ·åƒï¼Œä¸€èµ·èƒ–ï¼
        </p>
    </header>

         <!-- æ¸¸æˆå®¹å™¨ -->
     <main class="relative w-full max-w-6xl">
        <!-- ç©å®¶ä¿¡æ¯å’Œåˆ†æ•°é¢æ¿ -->
        <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-user text-memeBlue mr-2"></i>
                    <span class="text-xl">ç©å®¶: <span id="playerName" class="text-memeGreen font-bold">åŒ¿åç©å®¶</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-star text-memeYellow mr-2"></i>
                    <span class="text-xl">åˆ†æ•°: <span id="score" class="text-memeGreen font-bold">0</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-users text-memePink mr-2"></i>
                    <span class="text-xl">åœ¨çº¿: <span id="playerCount" class="text-memeBlue font-bold">0</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-gamepad text-memeRed mr-2"></i>
                    <span class="text-xl">æˆ¿é—´: <span id="roomName" class="text-memeBlue font-bold">é»˜è®¤æˆ¿é—´</span></span>
                </div>
            </div>
        </div>
        
        <!-- æ¸¸æˆç”»å¸ƒå®¹å™¨ -->
        <div class="relative border-4 border-memePink rounded-lg overflow-hidden bg-gray-800 shadow-lg">
            <canvas id="gameCanvas" class="w-full h-auto bg-gray-900"></canvas>
            
            <!-- å¼€å§‹å±å¹• -->
            <div id="startScreen" class="absolute inset-0 bg-gray-900/90 flex flex-col items-center justify-center z-10">
                <h2 class="text-4xl font-bold text-memeYellow mb-6 bounce-meme">å‡†å¤‡å¥½å’Œæœ‹å‹ä¸€èµ·ç©äº†å—ï¼Ÿ</h2>
                <div class="mb-4 w-full max-w-xs">
                    <label for="playerNameInput" class="block text-left mb-2 text-memeGreen">ä½ çš„æ˜µç§°</label>
                    <input type="text" id="playerNameInput" 
                           class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme"
                           placeholder="è¾“å…¥ä½ çš„åå­—">
                </div>
                <div class="mb-4 w-full max-w-xs">
                    <label for="roomSelect" class="block text-left mb-2 text-memeBlue">é€‰æ‹©æˆ¿é—´</label>
                    <select id="roomSelect" class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme">
                        <option value="default">é»˜è®¤æˆ¿é—´</option>
                        <option value="room1">æˆ¿é—´1 - æ–°æ‰‹åŒº</option>
                        <option value="room2">æˆ¿é—´2 - é«˜æ‰‹åŒº</option>
                        <option value="room3">æˆ¿é—´3 - ä¼‘é—²åŒº</option>
                    </select>
                </div>
                <div class="mb-6 w-full max-w-xs">
                    <label class="block text-left mb-2 text-memePink">é€‰æ‹©é¢œè‰²</label>
                    <div class="flex gap-2 flex-wrap">
                        <button class="color-btn w-8 h-8 rounded-full bg-memeRed border-2 border-white" data-color="#FF3333"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeBlue border-2" data-color="#0066FF"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeGreen border-2" data-color="#33CC33"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeYellow border-2" data-color="#FFE100"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memePink border-2" data-color="#FF66CC"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-orange-500 border-2" data-color="#FF9900"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-purple-500 border-2" data-color="#9966FF"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-cyan-500 border-2" data-color="#66CCFF"></button>
                    </div>
                </div>
                <button id="startBtn" class="bg-memeRed hover:bg-memeRed/80 text-white text-2xl py-3 px-8 rounded-full transform transition-transform hover:scale-110 active:scale-95 font-bold shadow-lg">
                    åŠ å…¥æ¸¸æˆ <i class="fa fa-play ml-2"></i>
                </button>
            </div>
            
            <!-- æ¸¸æˆç»“æŸå±å¹• -->
            <div id="gameOverScreen" class="absolute inset-0 bg-gray-900/95 flex flex-col items-center justify-center z-10 hidden">
                <h2 class="text-5xl font-bold text-memeRed mb-4 wiggle">æ¸¸æˆç»“æŸï¼</h2>
                <p class="text-2xl mb-2">ä½ çš„åˆ†æ•°: <span id="finalScore" class="text-memeGreen font-bold">0</span></p>
                <p class="text-xl mb-4">æ’è¡Œæ¦œ:</p>
                <ul id="leaderboard" class="mb-8 bg-gray-800 p-4 rounded-lg w-64">
                    <!-- æ’è¡Œæ¦œä¼šåœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </ul>
                <button id="restartBtn" class="bg-memeGreen hover:bg-memeGreen/80 text-white text-2xl py-3 px-8 rounded-full transform transition-transform hover:scale-110 active:scale-95 font-bold shadow-lg">
                    å†æ¥ä¸€å±€ <i class="fa fa-refresh ml-2"></i>
                </button>
            </div>
            
            <!-- æš‚åœæŒ‰é’® -->
            <button id="pauseBtn" class="absolute top-4 right-4 bg-gray-800/70 hover:bg-gray-700 text-white p-2 rounded-full z-5 hidden">
                <i class="fa fa-pause text-xl"></i>
            </button>
            
            <!-- æˆ¿é—´åˆ‡æ¢æŒ‰é’® -->
            <button id="roomSwitchBtn" class="absolute top-4 left-4 bg-gray-800/70 hover:bg-gray-700 text-white p-2 rounded-full z-5 hidden">
                <i class="fa fa-exchange text-xl"></i>
            </button>
        </div>
        
        <!-- æ¸¸æˆæ§åˆ¶å’Œç©å®¶åˆ—è¡¨ -->
        <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="bg-gray-800 p-4 rounded-lg border border-memeBlue">
                <h3 class="text-memeBlue text-xl font-bold mb-2">æ¸¸æˆè¯´æ˜</h3>
                <ul class="list-disc pl-5 space-y-1">
                    <li>åƒæ‰é£Ÿç‰©è®©è›‡å˜é•¿</li>
                    <li>æ’åˆ°å¢™å£ã€è‡ªå·±æˆ–å…¶ä»–ç©å®¶ä¼šæ­»äº¡</li>
                    <li>åˆ†æ•°è¶Šé«˜ï¼Œé€Ÿåº¦è¶Šå¿«</li>
                    <li>åƒåˆ°ç‰¹æ®Šé£Ÿç‰©æœ‰æƒŠå–œï¼</li>
                    <li>æŒ‰ç©ºæ ¼é”®æš‚åœ/ç»§ç»­</li>
                </ul>
            </div>
            <div class="bg-gray-800 p-4 rounded-lg border border-memeGreen">
                <h3 class="text-memeGreen text-xl font-bold mb-2">å½“å‰ç©å®¶</h3>
                <ul id="playersList" class="space-y-2 max-h-32 overflow-y-auto">
                    <!-- ç©å®¶åˆ—è¡¨ä¼šåœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </ul>
            </div>
        </div>
        
        <!-- æˆ¿é—´ç»Ÿè®¡ -->
        <div class="mt-4 bg-gray-800 p-4 rounded-lg border border-memeYellow">
            <h3 class="text-memeYellow text-xl font-bold mb-2">æˆ¿é—´ç»Ÿè®¡</h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeGreen" id="totalPlayers">0</div>
                    <div class="text-sm text-gray-400">æ€»ç©å®¶æ•°</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeBlue" id="activePlayers">0</div>
                    <div class="text-sm text-gray-400">æ´»è·ƒç©å®¶</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeRed" id="roomHighScore">0</div>
                    <div class="text-sm text-gray-400">æˆ¿é—´æœ€é«˜åˆ†</div>
                </div>
            </div>
        </div>
        

    </main>
    
    <!-- é¡µè„š -->
    <footer class="mt-8 text-center text-gray-500 text-sm">
        <p>Â© 2023 å¤šäººè”æœº Meme è´ªåƒè›‡ | ç”¨ Firebase å®æ—¶åŒæ­¥ <i class="fa fa-bolt text-memeYellow"></i></p>
    </footer>

    <script>
        // Firebase é…ç½®
        const firebaseConfig = {
            apiKey: "AIzaSyA5Z5ieEbAcfQX0kxGSn9ldGXhzvAwx_8M",
            authDomain: "chat-294cc.firebaseapp.com",
            databaseURL: "https://chat-294cc-default-rtdb.firebaseio.com",
            projectId: "chat-294cc",
            storageBucket: "chat-294cc.firebasestorage.app",
            messagingSenderId: "913615304269",
            appId: "1:913615304269:web:0274ffaccb8e6b678e4e04",
            measurementId: "G-SJR9NDW86B"
        };

        // åˆå§‹åŒ– Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
        // æ¸¸æˆå¸¸é‡å’Œå˜é‡
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const playerCountElement = document.getElementById('playerCount');
        const playerNameElement = document.getElementById('playerName');
        const finalScoreElement = document.getElementById('finalScore');
        const leaderboardElement = document.getElementById('leaderboard');
        const playersListElement = document.getElementById('playersList');
        const roomNameElement = document.getElementById('roomName');
        const totalPlayersElement = document.getElementById('totalPlayers');
        const activePlayersElement = document.getElementById('activePlayers');
        const roomHighScoreElement = document.getElementById('roomHighScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const roomSwitchBtn = document.getElementById('roomSwitchBtn');
        const playerNameInput = document.getElementById('playerNameInput');
        const roomSelect = document.getElementById('roomSelect');
        
        // æ¸¸æˆçŠ¶æ€å˜é‡
        let playerId = null;
        let playerName = 'åŒ¿åç©å®¶';
        let snake = [];
        let otherPlayers = {};
        let foods = []; // æ”¹ä¸ºæ•°ç»„å­˜å‚¨å¤šä¸ªé£Ÿç‰©
        let specialFood = null;
        let corpseFoods = []; // æ­»äº¡ç©å®¶çš„è›‡èº«ä½“å˜æˆçš„é£Ÿç‰©
        let direction = '';
        let nextDirection = '';
        let score = 0;
        let level = 1;
                 let gameSpeed = 120; // æ¯«ç§’ï¼Œç¨å¾®åŠ å¿«é€Ÿåº¦é€‚åº”æ›´å¤§çš„æ¸¸æˆåŒºåŸŸ
        let gameLoop;
        let isGameRunning = false;
        let isPaused = false;
        let gameRoom = 'default'; // æ¸¸æˆæˆ¿é—´
        let playerColor = '';
        let playerAvatar = '';
        let gameMargin = 0; // æ¸¸æˆè¾¹è·ï¼ˆåŒ…è¾¹ï¼‰
        const MAX_FOODS = 5; // åœºä¸Šæœ€å¤šé£Ÿç‰©æ•°é‡
        
        // Memeå…ƒç´ 
        const memeFaces = ['(â—â€¢á´—â€¢â—)', '(Â¬â€¿Â¬)', '(Ê˜â€¿Ê˜)', '(â—”_â—”)', '(Â°ãƒ­Â°)'];
        const memeColors = [
            '#FFE100', '#0066FF', '#FF3333', '#33CC33', '#FF66CC',
            '#FF9900', '#9966FF', '#66CCFF', '#FF6666', '#99FF66'
        ];
        
                 // è®¾ç½®ç”»å¸ƒå°ºå¯¸
         function resizeCanvas() {
             const container = canvas.parentElement;
             // å¢åŠ ç”»å¸ƒå°ºå¯¸ï¼Œè®©æ¸¸æˆåŒºåŸŸæ›´å¤§
             canvas.width = Math.min(container.clientWidth, 1200); // æœ€å¤§å®½åº¦1200px
             canvas.height = Math.min(container.clientWidth * 0.8, 960); // æœ€å¤§é«˜åº¦960pxï¼Œä¿æŒ4:5æ¯”ä¾‹
             
             // è®¡ç®—è¾¹è·ï¼ˆåŒ…è¾¹ï¼‰
             const margin = Math.floor(canvas.width * 0.05); // 5%çš„è¾¹è·
             gameMargin = margin;
         }
        
        // åˆå§‹åŒ–æ—¶è°ƒæ•´å°ºå¯¸ï¼Œå¹¶ç›‘å¬çª—å£å¤§å°å˜åŒ–
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ç”Ÿæˆå”¯ä¸€ç©å®¶ID
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substring(2, 10);
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // ç”Ÿæˆç©å®¶ID
            playerId = generatePlayerId();
            
            // è·å–ç©å®¶åç§°å’Œæˆ¿é—´
            if (playerNameInput.value.trim()) {
                playerName = playerNameInput.value.trim();
            }
            gameRoom = roomSelect.value;
            playerNameElement.textContent = playerName;
            
            // æ›´æ–°æˆ¿é—´åç§°æ˜¾ç¤º
            const roomNames = {
                'default': 'é»˜è®¤æˆ¿é—´',
                'room1': 'æˆ¿é—´1 - æ–°æ‰‹åŒº',
                'room2': 'æˆ¿é—´2 - é«˜æ‰‹åŒº',
                'room3': 'æˆ¿é—´3 - ä¼‘é—²åŒº'
            };
            roomNameElement.textContent = roomNames[gameRoom] || 'é»˜è®¤æˆ¿é—´';
            
                                     // è®¾ç½®åˆå§‹è›‡ä½ç½®
            const gridSize = Math.floor(canvas.width / 40); // å‡å°ç½‘æ ¼å¤§å°ï¼Œå¢åŠ ç§»åŠ¨èŒƒå›´
            
            // è®¡ç®—æœ‰æ•ˆæ¸¸æˆåŒºåŸŸçš„ç½‘æ ¼æ•°é‡ï¼ˆè€ƒè™‘è¾¹è·ï¼‰
            const effectiveWidth = canvas.width - 2 * gameMargin;
            const effectiveHeight = canvas.height - 2 * gameMargin;
            const gridCols = Math.floor(effectiveWidth / gridSize);
            const gridRows = Math.floor(effectiveHeight / gridSize);
            
            // å®šä¹‰å‡ºç”Ÿç‚¹ï¼ˆä½¿ç”¨ç½‘æ ¼åæ ‡ï¼Œåœ¨æœ‰æ•ˆåŒºåŸŸå†…ï¼‰
            const spawnPoints = [
                {gridX: 5, gridY: 5},
                {gridX: gridCols - 5, gridY: 5},
                {gridX: 5, gridY: gridRows - 5},
                {gridX: gridCols - 5, gridY: gridRows - 5}
            ];
            const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            
            // è½¬æ¢ä¸ºåƒç´ åæ ‡ï¼ˆåŠ ä¸Šè¾¹è·åç§»ï¼‰
            const pixelX = gameMargin + spawnPoint.gridX * gridSize;
            const pixelY = gameMargin + spawnPoint.gridY * gridSize;
            
                                     snake = [
                { x: pixelX, y: pixelY },
                { x: pixelX - gridSize, y: pixelY },
                { x: pixelX - gridSize * 2, y: pixelY },
                { x: pixelX - gridSize * 3, y: pixelY }
            ];
            
            // åˆå§‹æ–¹å‘
            direction = 'right';
            nextDirection = 'right';
            
                         // é‡ç½®åˆ†æ•°å’Œç­‰çº§
             score = 0;
             level = 1;
             gameSpeed = 120; // ç¨å¾®åŠ å¿«é€Ÿåº¦é€‚åº”æ›´å¤§çš„æ¸¸æˆåŒºåŸŸ
            
            // æ›´æ–°UI
            updateScore();
            
            // ä¿å­˜ç©å®¶ä¿¡æ¯åˆ°Firebase
            savePlayerInfo();
            
            // ç›‘å¬å…¶ä»–ç©å®¶å’Œé£Ÿç‰©
            listenForGameUpdates();
            
            // åˆå§‹ç”Ÿæˆé£Ÿç‰©ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            database.ref(`rooms/${gameRoom}/foods`).once('value', (snapshot) => {
                if (!snapshot.exists() || !snapshot.val() || snapshot.val().length === 0) {
                    generateInitialFoods();
                }
            });
            
            // ç»˜åˆ¶åˆå§‹çŠ¶æ€
            draw();
        }
        
        // ä¿å­˜ç©å®¶ä¿¡æ¯åˆ°Firebase
        function savePlayerInfo() {
            const playerRef = database.ref(`rooms/${gameRoom}/players/${playerId}`);
            
            // è®¾ç½®ç©å®¶åˆå§‹ä¿¡æ¯
            playerRef.set({
                name: playerName,
                snake: snake,
                direction: direction,
                score: score,
                alive: true,
                color: playerColor || memeColors[Math.floor(Math.random() * memeColors.length)],
                room: gameRoom,
                lastActive: Date.now()
            });
            
            // å½“é¡µé¢å…³é—­æ—¶ç§»é™¤ç©å®¶
            window.addEventListener('beforeunload', () => {
                playerRef.remove();
            });
            
            // å®šæœŸæ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
            setInterval(() => {
                if (isGameRunning && !isPaused) {
                    playerRef.update({
                        lastActive: Date.now()
                    });
                }
            }, 5000);
        }
        
        // ç›‘å¬æ¸¸æˆæ›´æ–°
        function listenForGameUpdates() {
            // ç›‘å¬å…¶ä»–ç©å®¶
            database.ref(`rooms/${gameRoom}/players`).on('value', (snapshot) => {
                const players = snapshot.val() || {};
                otherPlayers = {};
                
                // æ›´æ–°ç©å®¶åˆ—è¡¨
                playersListElement.innerHTML = '';
                playerCountElement.textContent = Object.keys(players).length;
                
                let activeCount = 0;
                Object.keys(players).forEach(id => {
                    if (id !== playerId && players[id].alive) {
                        otherPlayers[id] = players[id];
                        activeCount++;
                    }
                    
                    // æ·»åŠ åˆ°ç©å®¶åˆ—è¡¨
                    const li = document.createElement('li');
                    li.className = id === playerId ? 'text-memeGreen font-bold' : '';
                    li.innerHTML = `<span style="color: ${players[id].color}">â—</span> ${players[id].name} (${players[id].score})`;
                    playersListElement.appendChild(li);
                });
                
                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                totalPlayersElement.textContent = Object.keys(players).length;
                activePlayersElement.textContent = activeCount + (isGameRunning ? 1 : 0);
                
                // æ›´æ–°æ’è¡Œæ¦œ
                updateLeaderboard(players);
            });
            
            // ç›‘å¬é£Ÿç‰©
            database.ref(`rooms/${gameRoom}/foods`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    foods = snapshot.val() || [];
                } else {
                    foods = [];
                }
            });
            
            // ç›‘å¬ç‰¹æ®Šé£Ÿç‰©
            database.ref(`rooms/${gameRoom}/specialFood`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    specialFood = snapshot.val();
                } else {
                    specialFood = null;
                }
            });
            
            // ç›‘å¬å°¸ä½“é£Ÿç‰©
            database.ref(`rooms/${gameRoom}/corpseFoods`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    corpseFoods = snapshot.val() || [];
                } else {
                    corpseFoods = [];
                }
            });
            
            // ç›‘å¬æˆ¿é—´æœ€é«˜åˆ†
            database.ref(`rooms/${gameRoom}/highScores`).on('value', (snapshot) => {
                const highScores = snapshot.val() || {};
                let maxScore = 0;
                
                Object.values(highScores).forEach(score => {
                    if (score.score > maxScore) {
                        maxScore = score.score;
                    }
                });
                
                roomHighScoreElement.textContent = maxScore;
            });
        }
        
        // æ›´æ–°æ’è¡Œæ¦œ
        function updateLeaderboard(players) {
            leaderboardElement.innerHTML = '';
            
            // æ’åºç©å®¶
            const sortedPlayers = Object.values(players)
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
            
            sortedPlayers.forEach((player, index) => {
                const li = document.createElement('li');
                li.className = index === 0 ? 'text-memeYellow font-bold' : 
                              index === 1 ? 'text-gray-300' : 
                              index === 2 ? 'text-amber-700' : '';
                li.innerHTML = `${index + 1}. ${player.name} - ${player.score}åˆ†`;
                leaderboardElement.appendChild(li);
            });
        }
        

        
        // ç”Ÿæˆåˆå§‹é£Ÿç‰©ï¼ˆç”Ÿæˆå¤šä¸ªé£Ÿç‰©ï¼‰
        function generateInitialFoods() {
            const gridSize = Math.floor(canvas.width / 40);
            const foodsToGenerate = Math.min(MAX_FOODS, 3); // åˆå§‹ç”Ÿæˆ3ä¸ªé£Ÿç‰©
            
            database.ref(`rooms/${gameRoom}/players`).once('value', (snapshot) => {
                const players = snapshot.val() || {};
                const newFoods = [];
                
                for (let i = 0; i < foodsToGenerate; i++) {
                    const newFood = generateSingleFood(players, newFoods);
                    if (newFood) {
                        newFoods.push(newFood);
                    }
                }
                
                // ä¿å­˜æ‰€æœ‰é£Ÿç‰©åˆ°Firebase
                database.ref(`rooms/${gameRoom}/foods`).set(newFoods);
            });
        }
        
        // ç”Ÿæˆå•ä¸ªé£Ÿç‰©
        function generateSingleFood(players, existingFoods = []) {
            const gridSize = Math.floor(canvas.width / 40);
            let attempts = 0;
            const maxAttempts = 100;
            
            while (attempts < maxAttempts) {
                attempts++;
                // è®¡ç®—æœ‰æ•ˆæ¸¸æˆåŒºåŸŸçš„ç½‘æ ¼æ•°é‡ï¼ˆè€ƒè™‘è¾¹è·ï¼‰
                const effectiveWidth = canvas.width - 2 * gameMargin;
                const effectiveHeight = canvas.height - 2 * gameMargin;
                const gridCols = Math.floor(effectiveWidth / gridSize);
                const gridRows = Math.floor(effectiveHeight / gridSize);
                
                // ç”Ÿæˆéšæœºç½‘æ ¼åæ ‡ï¼ˆåœ¨æœ‰æ•ˆåŒºåŸŸå†…ï¼‰
                const gridX = Math.floor(Math.random() * gridCols);
                const gridY = Math.floor(Math.random() * gridRows);
                
                // è½¬æ¢ä¸ºåƒç´ åæ ‡ï¼ˆåŠ ä¸Šè¾¹è·åç§»ï¼‰
                const pixelX = gameMargin + gridX * gridSize;
                const pixelY = gameMargin + gridY * gridSize;
                
                const newFood = {
                    x: pixelX,
                    y: pixelY,
                    color: memeColors[Math.floor(Math.random() * memeColors.length)],
                    meme: memeFaces[Math.floor(Math.random() * memeFaces.length)],
                    timestamp: Date.now(),
                    id: 'food_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9)
                };
                
                let validPosition = true;
                
                // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰ç©å®¶è›‡èº«é‡å 
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
                
                if (!validPosition) continue;
                
                // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–ç©å®¶è›‡èº«é‡å 
                Object.values(players).forEach(player => {
                    if (player.snake && player.alive) {
                        for (let segment of player.snake) {
                            if (segment.x === newFood.x && segment.y === newFood.y) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    if (!validPosition) return;
                });
                
                // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰é£Ÿç‰©é‡å 
                existingFoods.forEach(food => {
                    if (food.x === newFood.x && food.y === newFood.y) {
                        validPosition = false;
                    }
                });
                
                // æ£€æŸ¥æ˜¯å¦ä¸å°¸ä½“é£Ÿç‰©é‡å 
                if (corpseFoods && corpseFoods.length > 0) {
                    corpseFoods.forEach(corpseFood => {
                        if (corpseFood.x === newFood.x && corpseFood.y === newFood.y) {
                            validPosition = false;
                        }
                    });
                }
                
                if (validPosition) {
                    return newFood;
                }
            }
            
            // å¦‚æœæ‰¾ä¸åˆ°æœ‰æ•ˆä½ç½®ï¼Œè¿”å›null
            return null;
        }
        
        // ç”Ÿæˆæ™®é€šé£Ÿç‰©ï¼ˆå½“é£Ÿç‰©è¢«åƒæ‰æ—¶è°ƒç”¨ï¼‰
        function generateFood() {
            const gridSize = Math.floor(canvas.width / 40);
            
            // ç¡®ä¿é£Ÿç‰©ä¸ä¼šå‡ºç°åœ¨ä»»ä½•è›‡èº«ä¸Š
            database.ref(`rooms/${gameRoom}/players`).once('value', (snapshot) => {
                const players = snapshot.val() || {};
                
                // è·å–å½“å‰é£Ÿç‰©åˆ—è¡¨
                database.ref(`rooms/${gameRoom}/foods`).once('value', (foodsSnapshot) => {
                    const currentFoods = foodsSnapshot.val() || [];
                    
                    // å¦‚æœå½“å‰é£Ÿç‰©æ•°é‡å°‘äºæœ€å¤§æ•°é‡ï¼Œç”Ÿæˆæ–°é£Ÿç‰©
                    if (currentFoods.length < MAX_FOODS) {
                        const newFood = generateSingleFood(players, currentFoods);
                        if (newFood) {
                            currentFoods.push(newFood);
                            database.ref(`rooms/${gameRoom}/foods`).set(currentFoods);
                        }
                    }
                });
            });
        }
        
                         // ç”Ÿæˆç‰¹æ®Šé£Ÿç‰©
        function generateSpecialFood() {
            const gridSize = Math.floor(canvas.width / 40);
            let newFood;
            
            // ç¡®ä¿ç‰¹æ®Šé£Ÿç‰©ä¸ä¼šå‡ºç°åœ¨ä»»ä½•è›‡èº«ä¸Šæˆ–æ™®é€šé£Ÿç‰©ä½ç½®
            database.ref(`rooms/${gameRoom}/players`).once('value', (playersSnapshot) => {
                database.ref(`rooms/${gameRoom}/foods`).once('value', (foodsSnapshot) => {
                    const players = playersSnapshot.val() || {};
                    const currentFoods = foodsSnapshot.val() || [];
                    let validPosition = false;
                    
                    while (!validPosition) {
                        // è®¡ç®—æœ‰æ•ˆæ¸¸æˆåŒºåŸŸçš„ç½‘æ ¼æ•°é‡ï¼ˆè€ƒè™‘è¾¹è·ï¼‰
                        const effectiveWidth = canvas.width - 2 * gameMargin;
                        const effectiveHeight = canvas.height - 2 * gameMargin;
                        const gridCols = Math.floor(effectiveWidth / gridSize);
                        const gridRows = Math.floor(effectiveHeight / gridSize);
                        
                        // ç”Ÿæˆéšæœºç½‘æ ¼åæ ‡ï¼ˆåœ¨æœ‰æ•ˆåŒºåŸŸå†…ï¼‰
                        const gridX = Math.floor(Math.random() * gridCols);
                        const gridY = Math.floor(Math.random() * gridRows);
                        
                        // è½¬æ¢ä¸ºåƒç´ åæ ‡ï¼ˆåŠ ä¸Šè¾¹è·åç§»ï¼‰
                        const pixelX = gameMargin + gridX * gridSize;
                        const pixelY = gameMargin + gridY * gridSize;
                        
                        newFood = {
                            x: pixelX,
                            y: pixelY,
                            color: '#FFFFFF',
                            meme: 'âœ¨',
                            timestamp: Date.now(),
                            timer: 50 // å­˜åœ¨50ä¸ªæ¸¸æˆå¸§
                        };
                        
                        validPosition = true;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸æ™®é€šé£Ÿç‰©é‡å 
                        currentFoods.forEach(food => {
                            if (food.x === newFood.x && food.y === newFood.y) {
                                validPosition = false;
                            }
                        });
                        
                        if (!validPosition) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸å°¸ä½“é£Ÿç‰©é‡å 
                        if (corpseFoods && corpseFoods.length > 0) {
                            corpseFoods.forEach(corpseFood => {
                                if (corpseFood.x === newFood.x && corpseFood.y === newFood.y) {
                                    validPosition = false;
                                }
                            });
                        }
                        
                        if (!validPosition) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰ç©å®¶è›‡èº«é‡å 
                        for (let segment of snake) {
                            if (segment.x === newFood.x && segment.y === newFood.y) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        if (!validPosition) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–ç©å®¶è›‡èº«é‡å 
                        Object.values(players).forEach(player => {
                            if (player.snake && player.alive) {
                                for (let segment of player.snake) {
                                    if (segment.x === newFood.x && segment.y === newFood.y) {
                                        validPosition = false;
                                        break;
                                    }
                                }
                            }
                            if (!validPosition) return;
                        });
                    }
                    
                    // ä¿å­˜ç‰¹æ®Šé£Ÿç‰©åˆ°Firebase
                    database.ref(`rooms/${gameRoom}/specialFood`).set(newFood);
                    
                    // 5ç§’åç§»é™¤ç‰¹æ®Šé£Ÿç‰©
                    setTimeout(() => {
                        database.ref(`rooms/${gameRoom}/specialFood`).once('value', (snapshot) => {
                            if (snapshot.exists() && snapshot.val().timestamp === newFood.timestamp) {
                                database.ref(`rooms/${gameRoom}/specialFood`).remove();
                            }
                        });
                    }, 5000);
                });
            });
        }
        
        // æ›´æ–°åˆ†æ•°
        function updateScore() {
            scoreElement.textContent = score;
            finalScoreElement.textContent = score;
            
            // æ›´æ–°Firebaseä¸­çš„åˆ†æ•°
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    score: score
                });
            }
        }
        
                         // æ£€æŸ¥ç¢°æ’
        function checkCollision() {
            const head = snake[0];
            const gridSize = Math.floor(canvas.width / 40); // å‡å°ç½‘æ ¼å¤§å°ï¼Œå¢åŠ ç§»åŠ¨èŒƒå›´
            
            // æ£€æŸ¥å¢™å£ç¢°æ’ï¼ˆè€ƒè™‘è¾¹è·ï¼‰
            if (head.x < gameMargin || head.x >= canvas.width - gameMargin || 
                head.y < gameMargin || head.y >= canvas.height - gameMargin) {
                return true;
            }
            
            // æ£€æŸ¥è‡ªèº«ç¢°æ’
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            
            // æ£€æŸ¥ä¸å…¶ä»–ç©å®¶ç¢°æ’ï¼ˆåŒ…æ‹¬æ­»äº¡ç©å®¶çš„è›‡èº«ä½“ï¼‰
            Object.values(otherPlayers).forEach(player => {
                if (player.snake) {
                    for (let segment of player.snake) {
                        if (head.x === segment.x && head.y === segment.y) {
                            return true;
                        }
                    }
                }
            });
            
            return false;
        }
        
        // æ£€æŸ¥é£Ÿç‰©ç¢°æ’
        function checkFoodCollision() {
            const head = snake[0];
            const gridSize = Math.floor(canvas.width / 40);
            let ateFood = false;
            
            // æ£€æŸ¥æ™®é€šé£Ÿç‰©ç¢°æ’
            if (foods && foods.length > 0) {
                for (let i = 0; i < foods.length; i++) {
                    const food = foods[i];
                    
                    // è°ƒè¯•ä¿¡æ¯ï¼šæ˜¾ç¤ºè›‡å¤´å’Œé£Ÿç‰©çš„åæ ‡
                    console.log('ç¢°æ’æ£€æµ‹:', {
                        head: {x: head.x, y: head.y},
                        food: {x: food.x, y: food.y},
                        gridSize: gridSize,
                        distance: Math.sqrt(Math.pow(head.x - food.x, 2) + Math.pow(head.y - food.y, 2))
                    });
                    
                    // ä½¿ç”¨æ›´å®½æ¾çš„ç¢°æ’æ£€æµ‹
                    if (Math.abs(head.x - food.x) < gridSize/2 && Math.abs(head.y - food.y) < gridSize/2) {
                        console.log('åƒåˆ°æ™®é€šé£Ÿç‰©!', {head, food}); // è°ƒè¯•ä¿¡æ¯
                        
                        // å¢åŠ åˆ†æ•°
                        score += 10;
                        
                        // æ¯100åˆ†å‡çº§
                        if (score % 100 === 0) {
                            level++;
                            // åŠ å¿«æ¸¸æˆé€Ÿåº¦ï¼Œæœ€ä½50ms
                            gameSpeed = Math.max(50, gameSpeed - 10);
                            // é‡æ–°è®¾ç½®æ¸¸æˆå¾ªç¯é€Ÿåº¦
                            if (isGameRunning && !isPaused) {
                                clearInterval(gameLoop);
                                gameLoop = setInterval(gameUpdate, gameSpeed);
                            }
                        }
                        
                        updateScore();
                        
                        // ç§»é™¤è¢«åƒæ‰çš„é£Ÿç‰©
                        const updatedFoods = foods.filter((_, index) => index !== i);
                        database.ref(`rooms/${gameRoom}/foods`).set(updatedFoods);
                        
                        // ç”Ÿæˆæ–°é£Ÿç‰©
                        generateFood();
                        
                        // æœ‰10%çš„å‡ ç‡ç”Ÿæˆç‰¹æ®Šé£Ÿç‰©
                        if (Math.random() < 0.1) {
                            generateSpecialFood();
                        }
                        
                        ateFood = true;
                        break; // ä¸€æ¬¡åªèƒ½åƒä¸€ä¸ªé£Ÿç‰©
                    }
                }
            }
            
            // æ£€æŸ¥å°¸ä½“é£Ÿç‰©ç¢°æ’
            if (corpseFoods && corpseFoods.length > 0) {
                for (let i = 0; i < corpseFoods.length; i++) {
                    const corpseFood = corpseFoods[i];
                    
                    // ä½¿ç”¨æ›´å®½æ¾çš„ç¢°æ’æ£€æµ‹
                    if (Math.abs(head.x - corpseFood.x) < gridSize/2 && Math.abs(head.y - corpseFood.y) < gridSize/2) {
                        console.log('åƒåˆ°å°¸ä½“é£Ÿç‰©!', {head, corpseFood}); // è°ƒè¯•ä¿¡æ¯
                        
                        // å°¸ä½“é£Ÿç‰©åªåŠ åˆ†æ•°ï¼Œä¸å¢åŠ è›‡é•¿åº¦
                        score += 5;
                        updateScore();
                        
                        // ç§»é™¤è¢«åƒæ‰çš„å°¸ä½“é£Ÿç‰©
                        const updatedCorpseFoods = corpseFoods.filter((_, index) => index !== i);
                        database.ref(`rooms/${gameRoom}/corpseFoods`).set(updatedCorpseFoods);
                        
                        // æ³¨æ„ï¼šä¸åƒå°¸ä½“é£Ÿç‰©ï¼Œæ‰€ä»¥ä¸è®¾ç½®ateFood = true
                        break; // ä¸€æ¬¡åªèƒ½åƒä¸€ä¸ªé£Ÿç‰©
                    }
                }
            }
            
            // ç‰¹æ®Šé£Ÿç‰© - ä½¿ç”¨æ›´å®½æ¾çš„ç¢°æ’æ£€æµ‹
            if (specialFood && Math.abs(head.x - specialFood.x) < gridSize/2 && Math.abs(head.y - specialFood.y) < gridSize/2) {
                console.log('åƒåˆ°ç‰¹æ®Šé£Ÿç‰©!', {head, specialFood}); // è°ƒè¯•ä¿¡æ¯
                
                // ç‰¹æ®Šé£Ÿç‰©ç»™æ›´å¤šåˆ†æ•°
                score += 50;
                updateScore();
                database.ref(`rooms/${gameRoom}/specialFood`).remove();
                ateFood = true;
            }
            
            return ateFood;
        }
        
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function gameUpdate() {
            if (isPaused) return;
            
                         // æ›´æ–°æ–¹å‘
             direction = nextDirection;
             
             const gridSize = Math.floor(canvas.width / 40); // å‡å°ç½‘æ ¼å¤§å°ï¼Œå¢åŠ ç§»åŠ¨èŒƒå›´
            const head = { x: snake[0].x, y: snake[0].y };
            
            // æ ¹æ®æ–¹å‘ç§»åŠ¨è›‡å¤´
            switch (direction) {
                case 'up':
                    head.y -= gridSize;
                    break;
                case 'down':
                    head.y += gridSize;
                    break;
                case 'left':
                    head.x -= gridSize;
                    break;
                case 'right':
                    head.x += gridSize;
                    break;
            }
            
            // å°†æ–°å¤´éƒ¨æ·»åŠ åˆ°è›‡
            snake.unshift(head);
            
            // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
            const ateFood = checkFoodCollision();
            
            // å¦‚æœæ²¡åƒåˆ°é£Ÿç‰©ï¼Œç§»é™¤å°¾éƒ¨
            if (!ateFood) {
                snake.pop();
            }
            
            // æ£€æŸ¥ç¢°æ’
            if (checkCollision()) {
                gameOver();
                return;
            }
            
            // æ›´æ–°Firebaseä¸­çš„è›‡çŠ¶æ€
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    snake: snake,
                    direction: direction
                });
            }
            
            // ç»˜åˆ¶æ¸¸æˆ
            draw();
        }
        
                 // ç»˜åˆ¶æ¸¸æˆ
         function draw() {
             const gridSize = Math.floor(canvas.width / 40); // å‡å°ç½‘æ ¼å¤§å°ï¼Œå¢åŠ ç§»åŠ¨èŒƒå›´
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#121212';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è¾¹è·åŒºåŸŸï¼ˆåŒ…è¾¹ï¼‰
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, gameMargin); // ä¸Šè¾¹è·
            ctx.fillRect(0, canvas.height - gameMargin, canvas.width, gameMargin); // ä¸‹è¾¹è·
            ctx.fillRect(0, 0, gameMargin, canvas.height); // å·¦è¾¹è·
            ctx.fillRect(canvas.width - gameMargin, 0, gameMargin, canvas.height); // å³è¾¹è·
            
            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯ï¼ˆä»…åœ¨æœ‰æ•ˆæ¸¸æˆåŒºåŸŸå†…ï¼‰
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            
            // åªåœ¨æœ‰æ•ˆæ¸¸æˆåŒºåŸŸå†…ç»˜åˆ¶ç½‘æ ¼
            for (let x = gameMargin; x < canvas.width - gameMargin; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, gameMargin);
                ctx.lineTo(x, canvas.height - gameMargin);
                ctx.stroke();
            }
            
            for (let y = gameMargin; y < canvas.height - gameMargin; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(gameMargin, y);
                ctx.lineTo(canvas.width - gameMargin, y);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶å…¶ä»–ç©å®¶çš„è›‡
            Object.values(otherPlayers).forEach(player => {
                if (player.snake) {
                    player.snake.forEach((segment, index) => {
                        // è›‡å¤´ç‰¹æ®Šæ ·å¼
                        if (index === 0) {
                            // è›‡å¤´èƒŒæ™¯
                            ctx.fillStyle = player.color;
                            ctx.shadowColor = player.color;
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            
                            // è›‡å¤´è¡¨æƒ…
                            ctx.fillStyle = 'white';
                            ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('ğŸ˜œ', segment.x + gridSize / 2, segment.y + gridSize / 2);
                            
                            // ç©å®¶åç§°æ ‡ç­¾
                            ctx.fillStyle = player.color;
                            ctx.font = `${gridSize * 0.4}px "Comic Sans MS", cursive`;
                            ctx.fillText(player.name, segment.x + gridSize / 2, segment.y - 10);
                        } else {
                            // è›‡èº«
                            ctx.fillStyle = player.color;
                            
                            // è›‡èº«éšæœºæ—‹è½¬
                            const rotation = (Math.sin(index * 0.5) * 10);
                            
                            ctx.save();
                            ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                            ctx.rotate(rotation * Math.PI / 180);
                            
                            // è›‡èº«å½¢çŠ¶
                            ctx.beginPath();
                            ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.restore();
                        }
                    });
                }
            });
            
            // ç»˜åˆ¶è‡ªå·±çš„è›‡
            snake.forEach((segment, index) => {
                // è›‡å¤´ç‰¹æ®Šæ ·å¼
                if (index === 0) {
                    // è›‡å¤´èƒŒæ™¯
                    ctx.fillStyle = '#FF3333';
                    ctx.shadowColor = '#FF3333';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // è›‡å¤´è¡¨æƒ…
                    ctx.fillStyle = 'white';
                    ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ğŸ˜›', segment.x + gridSize / 2, segment.y + gridSize / 2);
                    
                    // è‡ªå·±çš„åç§°æ ‡ç­¾
                    ctx.fillStyle = '#FF3333';
                    ctx.font = `${gridSize * 0.4}px "Comic Sans MS", cursive`;
                    ctx.fillText(playerName, segment.x + gridSize / 2, segment.y - 10);
                } else {
                    // è›‡èº«ä½¿ç”¨éšæœºmemeé¢œè‰²
                    const colorIndex = (index % memeColors.length);
                    ctx.fillStyle = memeColors[colorIndex];
                    
                    // è›‡èº«éšæœºæ—‹è½¬
                    const rotation = (Math.sin(index * 0.5) * 10);
                    
                    ctx.save();
                    ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                    ctx.rotate(rotation * Math.PI / 180);
                    
                                            // è›‡èº«å½¢çŠ¶
                        ctx.beginPath();
                        ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    
                    ctx.restore();
                }
            });
            
                         // ç»˜åˆ¶æ™®é€šé£Ÿç‰©
             if (foods && foods.length > 0) {
                 foods.forEach(food => {
                     ctx.fillStyle = food.color;
                     ctx.shadowColor = food.color;
                     ctx.shadowBlur = 10;
                     ctx.beginPath();
                     ctx.arc(food.x + gridSize / 2, food.y + gridSize / 2, gridSize / 2, 0, Math.PI * 2);
                     ctx.fill();
                     ctx.shadowBlur = 0;
                     
                     // é£Ÿç‰©ä¸Šçš„memeè¡¨æƒ…
                     ctx.fillStyle = 'black';
                     ctx.font = `${gridSize * 0.5}px "Comic Sans MS", cursive`;
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.fillText(food.meme, food.x + gridSize / 2, food.y + gridSize / 2);
                 });
             }
            
                         // ç»˜åˆ¶å°¸ä½“é£Ÿç‰©
             if (corpseFoods && corpseFoods.length > 0) {
                 corpseFoods.forEach(corpseFood => {
                     // ä¿å­˜å½“å‰ä¸Šä¸‹æ–‡
                     ctx.save();
                     
                     // è®¡ç®—åŠ¨ç”»æ•ˆæœ
                     const time = Date.now() / 1000;
                     const pulseScale = 1 + Math.sin(time * (corpseFood.pulse || 2)) * 0.1;
                     const wiggleOffset = Math.sin(time * 3) * (corpseFood.wiggle || 3);
                     const rotation = (corpseFood.rotation || 0) + Math.sin(time * 2) * 10;
                     
                     // è®¾ç½®å˜æ¢
                     ctx.translate(corpseFood.x + gridSize / 2 + wiggleOffset, corpseFood.y + gridSize / 2);
                     ctx.rotate(rotation * Math.PI / 180);
                     ctx.scale(pulseScale, pulseScale);
                     
                     // ç»˜åˆ¶å‘å…‰èƒŒæ™¯
                     const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gridSize / 2);
                     gradient.addColorStop(0, corpseFood.color);
                     gradient.addColorStop(0.7, corpseFood.color + '80');
                     gradient.addColorStop(1, 'transparent');
                     
                     ctx.fillStyle = gradient;
                     ctx.shadowColor = corpseFood.color;
                     ctx.shadowBlur = 20;
                     ctx.beginPath();
                     ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                     ctx.fill();
                     
                     // ç»˜åˆ¶è¾¹æ¡†
                     ctx.strokeStyle = '#FFFFFF';
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.arc(0, 0, gridSize / 2 - 2, 0, Math.PI * 2);
                     ctx.stroke();
                     
                     // é‡ç½®é˜´å½±
                     ctx.shadowBlur = 0;
                     
                     // ç»˜åˆ¶memeè¡¨æƒ…
                     ctx.fillStyle = '#FFFFFF';
                     ctx.font = `bold ${gridSize * 0.6}px "Comic Sans MS", cursive`;
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.fillText(corpseFood.meme, 0, 0);
                     
                     // æ¢å¤ä¸Šä¸‹æ–‡
                     ctx.restore();
                     
                     // æ˜¾ç¤ºæ­»äº¡ç©å®¶çš„åå­—ï¼ˆå¸¦ç‰¹æ•ˆï¼‰
                     ctx.save();
                     ctx.translate(corpseFood.x + gridSize / 2, corpseFood.y - 20);
                     
                     // åå­—èƒŒæ™¯
                     ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                     ctx.beginPath();
                     ctx.moveTo(-30, -10);
                     ctx.lineTo(30, -10);
                     ctx.lineTo(30, 10);
                     ctx.lineTo(-30, 10);
                     ctx.closePath();
                     ctx.fill();
                     
                     // åå­—æ–‡å­—
                     ctx.fillStyle = corpseFood.originalColor;
                     ctx.font = `bold ${gridSize * 0.25}px "Comic Sans MS", cursive`;
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.shadowColor = '#000000';
                     ctx.shadowBlur = 2;
                     ctx.fillText(corpseFood.playerName, 0, 0);
                     
                     ctx.restore();
                 });
             }
             
             // ç»˜åˆ¶ç‰¹æ®Šé£Ÿç‰©ï¼ˆé—ªçƒæ•ˆæœï¼‰
             if (specialFood) {
                 // é—ªçƒæ•ˆæœ
                 const opacity = 0.5 + Math.sin(Date.now() / 100) * 0.5;
                 
                 ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                 ctx.shadowColor = 'white';
                 ctx.shadowBlur = 20;
                 
                 // æ—‹è½¬åŠ¨ç”»
                 ctx.save();
                 ctx.translate(specialFood.x + gridSize / 2, specialFood.y + gridSize / 2);
                 ctx.rotate(Date.now() / 500);
                 
                 ctx.beginPath();
                 ctx.rect(-gridSize / 2, -gridSize / 2, gridSize, gridSize);
                 ctx.fill();
                 
                 // ç‰¹æ®Šç¬¦å·
                 ctx.fillStyle = 'gold';
                 ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText(specialFood.meme, 0, 0);
                 
                 ctx.restore();
                 ctx.shadowBlur = 0;
             }
        }
        
        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            if (isGameRunning) return;
            
            startScreen.classList.add('hidden');
            pauseBtn.classList.remove('hidden');
            roomSwitchBtn.classList.remove('hidden');
            isGameRunning = true;
            isPaused = false;
            
            // åˆå§‹åŒ–æ¸¸æˆ
            initGame();
            
            // å¯åŠ¨æ¸¸æˆå¾ªç¯
            gameLoop = setInterval(gameUpdate, gameSpeed);
        }
        
        // åˆ‡æ¢æˆ¿é—´
        function switchRoom() {
            if (!isGameRunning) return;
            
            // æš‚åœæ¸¸æˆ
            isPaused = true;
            
            // ç§»é™¤å½“å‰æˆ¿é—´çš„ç©å®¶æ•°æ®
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).remove();
            }
            
            // æ˜¾ç¤ºæˆ¿é—´é€‰æ‹©
            startScreen.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            roomSwitchBtn.classList.add('hidden');
            
            // åœæ­¢æ¸¸æˆå¾ªç¯
            clearInterval(gameLoop);
            isGameRunning = false;
            

        }
        
        // æš‚åœ/ç»§ç»­æ¸¸æˆ
        function togglePause() {
            if (!isGameRunning) return;
            
            isPaused = !isPaused;
            pauseBtn.innerHTML = isPaused ? 
                '<i class="fa fa-play text-xl"></i>' : 
                '<i class="fa fa-pause text-xl"></i>';
        }
        
        // æ¸¸æˆç»“æŸ
        function gameOver() {
            clearInterval(gameLoop);
            isGameRunning = false;
            gameOverScreen.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            
            // å°†æ­»äº¡çš„è›‡èº«ä½“å˜æˆå°¸ä½“é£Ÿç‰©
            createCorpseFoods();
            
            // æ›´æ–°ç©å®¶çŠ¶æ€ä¸ºæ­»äº¡
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    alive: false
                });
            }
            
            // ä¿å­˜æœ€é«˜åˆ†
            saveHighScore();
        }
        
        // åˆ›å»ºå°¸ä½“é£Ÿç‰©
        function createCorpseFoods() {
            if (snake && snake.length > 0) {
                const gridSize = Math.floor(canvas.width / 40);
                const newCorpseFoods = [];
                
                // éšæœºé€‰æ‹©memeè¡¨æƒ…
                const memeEmojis = ['ğŸ’€', 'â˜ ï¸', 'ğŸ‘»', 'ğŸ¤¡', 'ğŸ˜µ', 'ğŸ’©', 'ğŸ”¥', 'âš°ï¸', 'ğŸª¦', 'ğŸ§Ÿ'];
                const memeColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];
                
                // å°†è›‡èº«ä½“çš„æ¯ä¸ªéƒ¨åˆ†å˜æˆå°¸ä½“é£Ÿç‰©
                snake.forEach((segment, index) => {
                    const randomMeme = memeEmojis[Math.floor(Math.random() * memeEmojis.length)];
                    const randomColor = memeColors[Math.floor(Math.random() * memeColors.length)];
                    
                    const corpseFood = {
                        x: segment.x,
                        y: segment.y,
                        color: randomColor, // éšæœºmemeé¢œè‰²
                        meme: randomMeme,
                        timestamp: Date.now(),
                        id: 'corpse_' + Date.now() + '_' + index,
                        playerName: playerName,
                        originalColor: playerColor || '#FF3333',
                        rotation: Math.random() * 360, // éšæœºæ—‹è½¬è§’åº¦
                        pulse: Math.random() * 2 + 1, // éšæœºè„‰å†²é€Ÿåº¦
                        wiggle: Math.random() * 10 - 5 // éšæœºæ‘†åŠ¨å¹…åº¦
                    };
                    newCorpseFoods.push(corpseFood);
                });
                
                // è·å–ç°æœ‰çš„å°¸ä½“é£Ÿç‰©å¹¶æ·»åŠ æ–°çš„
                database.ref(`rooms/${gameRoom}/corpseFoods`).once('value', (snapshot) => {
                    const existingCorpseFoods = snapshot.val() || [];
                    const allCorpseFoods = [...existingCorpseFoods, ...newCorpseFoods];
                    database.ref(`rooms/${gameRoom}/corpseFoods`).set(allCorpseFoods);
                });
            }
        }
        
        // ä¿å­˜æœ€é«˜åˆ†
        function saveHighScore() {
            const highScoreRef = database.ref(`rooms/${gameRoom}/highScores/${playerId}`);
            highScoreRef.once('value', (snapshot) => {
                const currentHigh = snapshot.val() || 0;
                if (score > currentHigh) {
                    highScoreRef.set({
                        playerName: playerName,
                        score: score,
                        timestamp: Date.now()
                    });
                }
            });
        }
        
        // é‡å¯æ¸¸æˆ
        function restartGame() {
            // ç§»é™¤æ—§ç©å®¶æ•°æ®
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).remove();
            }
            
            gameOverScreen.classList.add('hidden');
            startGame();
        }
        
        // å¤„ç†é”®ç›˜è¾“å…¥
        function handleKeyPress(e) {
            // é˜»æ­¢æ–¹å‘é”®æ»šåŠ¨é¡µé¢
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            
            // åªåœ¨æ¸¸æˆè¿è¡Œæ—¶å¤„ç†æ–¹å‘é”®
            if (!isGameRunning && e.key !== ' ') return;
            
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction !== 'down') {
                        nextDirection = 'up';
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction !== 'up') {
                        nextDirection = 'down';
                    }
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction !== 'right') {
                        nextDirection = 'left';
                    }
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction !== 'left') {
                        nextDirection = 'right';
                    }
                    break;
                case ' ': // ç©ºæ ¼é”®æš‚åœ/ç»§ç»­
                    if (isGameRunning) {
                        togglePause();
                    } else if (!startScreen.classList.contains('hidden')) {
                        startGame();
                    }
                    break;
            }
        }
        
        // äº‹ä»¶ç›‘å¬
        document.addEventListener('keydown', handleKeyPress);
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', restartGame);
        pauseBtn.addEventListener('click', togglePause);
        roomSwitchBtn.addEventListener('click', switchRoom);
        
        // é¢œè‰²é€‰æ‹©
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // ç§»é™¤å…¶ä»–æŒ‰é’®çš„é€‰ä¸­çŠ¶æ€
                document.querySelectorAll('.color-btn').forEach(b => {
                    b.classList.remove('border-white');
                    b.classList.add('border-gray-600');
                });
                
                // é€‰ä¸­å½“å‰æŒ‰é’®
                btn.classList.remove('border-gray-600');
                btn.classList.add('border-white');
                
                // ä¿å­˜é€‰æ‹©çš„é¢œè‰²
                playerColor = btn.dataset.color;
            });
        });
        
        // é¢„å¡«å……ä¸€ä¸ªæç¬‘çš„ç©å®¶å
        playerNameInput.value = ['è´ªåƒè›‡ç‹', 'ä¸“ä¸šåƒè´§', 'è›‡è›‡æœå®èƒ½åŠ›è€…', ' memeså¤§å¸ˆ'][Math.floor(Math.random() * 4)];
        
        // é»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªé¢œè‰²
        document.querySelector('.color-btn').click();
    </script>
</body>
</html>
